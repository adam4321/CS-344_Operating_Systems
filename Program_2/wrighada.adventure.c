/******************************************************************************
**  Author:      Adam Wright
**  Email:       wrighada@oregonstate.edu
**  Date:        4/18/2020
**  Description: Program 2 for spring 2020 OSU cs-344. This program opens up
**               the room files generated by wrighada.buildrooms and then
**               uses them to form the layout of a maze which this program
**               allows the user to navigate.
******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <dirent.h>
#include <pthread.h>


/* Global Constants */
#define ROOM_COUNT  7
#define CONNECT_MAX 6
#define NUM_THREADS 2

/* Definition for the bool type */
typedef enum
{
    false,
    true
} bool;

/* Definition for the Room struct */
struct Room
{
    char *name;
    char *type;
    int connect_count;
    char *out_connect[CONNECT_MAX];
};

/* Global Variables */
struct Room *Room_Arr[ROOM_COUNT];      /* Array to hold the created rooms */
char newestDirName[256];                /* Array to hold the name of the newest directory */
int start_index;                        /* Variable to hold the start room's index in Room_Arr */
char *time_file = "currentTime.txt";    /* File to hold the currently requested time */
pthread_t threads[NUM_THREADS];         /* Declare 2 threads */
int result_code_1;                      /* Result code to test the main game thread */
int result_code_2;                      /* Result code to test the time printing thread */

/* Mutex for stopping the time function until it is released */
pthread_mutex_t time_lock = PTHREAD_MUTEX_INITIALIZER;


/* FUNCTION DECLARATIONS ----------------------------------------------------*/

void Get_Newest_Dir();
void Init_Room_Arr(struct Room *Room_Arr[]);
void Fill_Room_Arr(struct Room *Room_Arr[]);
int Get_Room_Index(char *Room);
void *Game_Loop(void *ptr);
void *Time_To_File(void *ptr);
void Time_From_File();
void Free_Memory();
void Print_Disgnostics();


/* MAIN ---------------------------------------------------------------------*/

int main()
{
    /* Search the current directory for the newest subdirectory */
    Get_Newest_Dir();

    /* Create and fill an array of struct rooms with the newest room data */
    Init_Room_Arr(Room_Arr);
    Fill_Room_Arr(Room_Arr);

    /* !! COMMENT OUT BEFORE RELEASE !! - Prints the current room data */
    /* Print_Disgnostics(); */

    /* Move back into the parent directory */
    chdir("..");

    /* Create the main game thread and join it */
    pthread_create(&threads[0], NULL, Game_Loop, NULL);
    pthread_join(threads[0], NULL);
    
    /* Free the heap allocated objects */
    Free_Memory();

    return 0;
}


/* FUNCTION DEFINITIONS -----------------------------------------------------*/

/*
*  Function:     void Get_Newest_Dir()
*  Description:  Function that finds the most recent room directory for building
*                out the rooms array
*/
void Get_Newest_Dir()
{
  int newestDirTime = -1; /* Modified timestamp of newest subdir examined */
  char targetDirPrefix[32] = "wrighada.rooms."; /* Prefix we're looking for */
  memset(newestDirName, '\0', sizeof(newestDirName)); /* newest directory that contains my prefix */

  DIR *dirToCheck; /*Holds the directory we're starting in */
  struct dirent *fileInDir; /* Holds the current subdir of the starting dir */
  struct stat dirAttributes; /* Holds information we've gained about subdir */

  dirToCheck = opendir("."); /* Open up the directory this program was run in */

    if (dirToCheck > 0) /* Make sure the current directory could be opened */
    {
        while ((fileInDir = readdir(dirToCheck)) != NULL) /* Check each entry in dir */
        {
            if (strstr(fileInDir->d_name, targetDirPrefix) != NULL) /* If entry has prefix */
            {
                stat(fileInDir->d_name, &dirAttributes); /*Get attributes of the entry */

                if ((int)dirAttributes.st_mtime > newestDirTime) /* If this time is bigger */
                {
                    newestDirTime = (int)dirAttributes.st_mtime;
                    memset(newestDirName, '\0', sizeof(newestDirName));
                    strcpy(newestDirName, fileInDir->d_name); /* Store the directory */
                }
            }
        }
    }

  closedir(dirToCheck); /* Close the directory we opened */
}


/*
*  Function:     void Init_Room_Arr()   
*  Description:  Initialize heap memory for the struct room array
*/
void Init_Room_Arr(struct Room *Room_Arr[])
{
    int i = 0;
    int j = 0;

    /* Create space on the heap for the struct rooms array */
    for (i = 0; i < ROOM_COUNT; i++)
    {
        Room_Arr[i] = malloc(sizeof(struct Room));
        Room_Arr[i]->name = malloc(16 * sizeof(char));
        Room_Arr[i]->type = malloc(16 * sizeof(char));
        Room_Arr[i]->connect_count = 0;

        /* Set all of the connection array values to 0 */
        for (j = 0; j < CONNECT_MAX; j++)
        {
            Room_Arr[i]->out_connect[j] = calloc(16, sizeof(char));
        }
    }
}


/*
*  Function:     void Fill_Room_Arr()
*  Description:  Fills the room array with data from most recent directory
*/
void Fill_Room_Arr(struct Room *Room_Arr[])
{
    DIR *newest_dir = opendir(newestDirName);
    struct dirent *file_in_dir;
    char *file_name;
    FILE *room_file;
    char line[255];
    int file_num = 0;
    int i;

    /* Iterate through the directory and grab the filenames */
    while (file_in_dir = readdir(newest_dir))
    {
        /* Iterate through the room files and populate the struct room data */
        if (file_in_dir->d_name[0] != '.')
        {
            /* Move into the directory and open each non-hidden file */
            chdir(newestDirName);
            file_name = file_in_dir->d_name;
            room_file = fopen(file_name, "r");

            /* Fill the receiving char array with null terminators */
            memset(line, '\0', sizeof(line));

            i = 0;
            /* Split each line to pull the target data */
            while (fgets(line, sizeof(line), room_file))
            {
                /* Split each line on whitespaces */
                strtok(line, " ");
                char *token_1 = strtok(NULL, " ");
                char *token_2 = strtok(NULL, " ");

                /* Remove the final characters */
                token_1[strlen(token_1) - 1] = '\0';
                token_2[strlen(token_2) - 1] = '\0';

                /* Assign the room name */
                if (strstr(token_1, "NAME"))
                {
                    strcpy(Room_Arr[file_num]->name, token_2);
                }
                /* Assign the room type */
                else if (strstr(token_1, "TYPE"))
                {
                    strcpy(Room_Arr[file_num]->type, token_2);

                    /* Find the starting room and store the value */
                    if (strcmp(token_2, "START_ROOM") == 0)
                    {
                        start_index = file_num;
                    }
                }
                /* Assign the connected rooms and connection count */
                else
                {
                    strcpy(Room_Arr[file_num]->out_connect[i], token_2);
                    Room_Arr[file_num]->connect_count++;
                    i++;
                }
            }
            
            /* Increment the iterator and close the previous file */
            file_num++;
            fclose(room_file);
        }
    }

    closedir(newest_dir);
}


/*
*  Function:     int Get_Room_Index(char *str)
*  Description:  Returns the index of a struct room or -1 if it isn't found.
*                It should never return -1 during normal operation.
*/
int Get_Room_Index(char *str)
{
    int i = 0;

    /* Find the name of the room passed in and return it's index */
    while (i < ROOM_COUNT)
    {
        if (strcmp(Room_Arr[i]->name, str) == 0)
        {
            return i;
        }

        i++;
    }

    /* This should not be reached because a room will be found */ 
    return -1;
}


/*
*  Function:     void *Game_Loop(void *ptr)
*  Description:  The function which runs the game loop. It is the main thread
*                which is threads[0]
*/
void *Game_Loop(void *ptr)
{
    /* Lock the main thread */
    pthread_mutex_lock(&time_lock);

    int i;                          /* Iterator */
    int j;                          /* Iterator */
    int current_index;              /* Index in Room_Arr of current_room  */
    int step_count = 0;             /* The number of steps taken in the game */
    struct Room *current_room;      /* Struct Room pointer to the current room */
    int rooms_visited[255];         /* Array holding the indices of the rooms visited */
    char input_buffer[255];         /* Array to hold the game input string */
    bool room_match = false;        /* Bool holding result of strcmp with inputted string */
    bool time_check = false;        /* Bool to only print where to after time request */

    /* Set the struct room pointer to the starting room */
    current_room = Room_Arr[start_index];

    /* Loop until the end room is reached */
    do
    {
        /* Only print the location and connections if not following a time request */
        if (time_check == false)
        {
            printf("CURRENT LOCATION: %s\n", current_room->name);
            printf("POSSIBLE CONNECTIONS:");

            /* Print the room's connections with the correct formatting */
            i = 0;
            while (i < current_room->connect_count - 1)
            {
                printf(" %s,", current_room->out_connect[i]);
                i++;
            }
            printf(" %s.\n", current_room->out_connect[i]);
        }

        /* Reset the time_check flag to print location and connections on next loop */
        time_check = false;
        printf("WHERE TO? >");

        /* Clear the input array and get the user's input */
        memset(input_buffer, '\0', sizeof(input_buffer));
        scanf("%254s", input_buffer);
        printf("\n");

        /* Print the time when requested */
        if (strcmp(input_buffer, "time") == 0)
        {
            /* Create the second time thread */
            pthread_create(&threads[1], NULL, Time_To_File, NULL);

            /* Unlock the main thread to let the time thread print */
            pthread_mutex_unlock(&time_lock);

            /* Join the time thread */
            pthread_join(threads[1], NULL);

            /* Relock the main thread after the time was printed */
            pthread_mutex_lock(&time_lock);

            /* Print the time gathered in thread two */
            Time_From_File();

            /* Set the time_check flag, so that only WHERE TO? is printed */ 
            time_check = true;
            continue;
        }
        /* Test the room request against the possible connections */
        else
        {
            i = 0;
            room_match = false;

            while (i < current_room->connect_count)
            {
                /* If a match is found then move to the new room */
                if (strcmp(input_buffer, current_room->out_connect[i]) == 0)
                {
                    room_match = true;
                    rooms_visited[step_count] = Get_Room_Index(current_room->out_connect[i]);

                    /* Update the index of the current room */
                    current_index = rooms_visited[step_count];

                    /* Set the struct room pointer to the current room */
                    current_room = Room_Arr[current_index];
                    step_count++;

                    /* If the end room is requested, then end the game */
                    if (strcmp(current_room->type, "END_ROOM") == 0)
                    {
                        printf("YOU HAVE FOUND THE END ROOM. CONGRATULATIONS!\n");
                        printf("YOU TOOK %d STEPS. YOUR PATH TO VICTORY WAS:\n", step_count);
                        
                        /* Print the rooms visited in the game */
                        j = 0;
                        while (j < step_count)
                        {
                            printf("%s\n", Room_Arr[rooms_visited[j]]->name);
                            j++;
                        }

                        /* End the game */
                        return NULL;
                    }
                }

                i++;
            }
            /* If no match then prompt the user to try again */
            if (room_match == false)
            {
                printf("HUH? I DON'T UNDERSTAND THAT ROOM. TRY AGAIN.\n\n");
            }
        }

    } while (true); 
}


/*
*  Function:     void *Time_To_File(void *ptr)
*  Description:  Prints the current time into currentTime.txt. It is runs as 
*                the second thread which is threads[1]. It can only run when
*                a mutex in the Game_Loop is released. This creates the correct
*                timing for generating an accurate current time.
*/
void *Time_To_File(void *ptr)
{
    /* Try to establish the lock */
    pthread_mutex_lock(&time_lock);

    /* Open the time file to accept the time/date string */
    char time_buffer[255];
    FILE *time_file_instance = fopen(time_file, "w");
    
    /* Retrieve the current local time */
    time_t t;
    struct tm *time_ptr;
    time(&t);
    time_ptr = localtime(&t);

    /* Format the current time and enter it into the open file */
    strftime(time_buffer, sizeof(time_buffer), "%l:%M%P, %A, %B%e, %Y", time_ptr);
    fprintf(time_file_instance, "%s\n", time_buffer);
    fclose(time_file_instance);

    /* Unlock the mutex */
    pthread_mutex_unlock(&time_lock);
}


/*
*  Function:     void Time_From_File()
*  Description:  Retrieve the current time from currentTime.txt
*/
void Time_From_File()
{
    /* Retrieve the time/date line and close the file */
    char current_time[255];
    FILE *time_file_instance = fopen(time_file, "r");
    fgets(current_time, sizeof(current_time), time_file_instance);
    fclose(time_file_instance);

    /* Print the current time within the game */
    printf("%s\n", current_time);
}


/*
*  Function:     void Free_Memory()
*  Description:  Free the array of room structs and each room's internal pointers
*/
void Free_Memory()
{
    int i;
    int j;
    
    /* Free the pointers within the structs first */
    for (i = 0; i < ROOM_COUNT; i++)
    {
        free(Room_Arr[i]->name);
        free(Room_Arr[i]->type);

        for (j = 0; j < CONNECT_MAX; j++)
        {
            free(Room_Arr[i]->out_connect[j]);
        }
        
        /* Free the struct in the room array itself */
        free(Room_Arr[i]);
    }
}


/*
*  Function:     void Print_Diagnostics()
*  Description:  Function to print the data gathered from the room files.
*                This function is for testing and is NOT called in the release
*                version. It MUST be commented out when testing is over!
*/
void Print_Disgnostics()
{
    int i;
    int j;

    /* Print the name of the newest directory */
    printf("\nNewest entry found is: %s\n\n", newestDirName);

    /* Iterate through the struct room array and print it's data */
    for (i = 0; i < ROOM_COUNT; i++)
    {
        printf("Name %d: %s\t", i, Room_Arr[i]->name);
        printf("Type: %s\n", Room_Arr[i]->type);
        printf("Connect Count: %d\n", Room_Arr[i]->connect_count);

        for (j = 0; j < CONNECT_MAX; j++)
        {
            printf("Connection %d: %s\n", j, Room_Arr[i]->out_connect[j]);
        }
        printf("\n");
    }

    /* Print the index within Room_Arr of the start room */
    printf("Start index: %d\n\n", start_index);
}
