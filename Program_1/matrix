#!/bin/bash

###############################################################################
##  Author:       Adam Wright
##  Email:        wrighada@oregonstate.edu
##  Date:         3-30-2020
##  Description:  Bash shell script with 5 callable functions
##                - dims [matrix] returns the dimensions of a valid matrix
##                - transpose [matrix] reflect the matrix elements MxN => NxM
##                - mean [matrix] returns means of each column of a matrix
##                - add [Matrix_left  Matrix_right] sums 2 equal dimension
##                  matrices element-wise
##                - multiply [Matrix_left  Matrix_right] returns to stdout the
##                  product of an MxN and NxP matrix and produce an MxP matrix 
###############################################################################


# Create unique temporary file for holding stdin input
TMP="temp_file$$"

# Define trap statement to erase this TMP file on an interrupt signal
trap "rm -f "temp_file$$"; echo 'CTRL+C received, exiting'; exit 1" INT HUP TERM


##  Functions
###############################################################################

# NAME
#   dims - returns the dimension of a valid matrix
# SYNOPSIS
#   dims [matrix]
# DESCRIPTION
#   Returns the row count and column count separated by a space to stdout
#   when it is given a valid matrix from stdin or a file

dims()
{
    # Count the number of words in line 1
    local col_count=$( head -n 1 $1 | wc -w )
    local row_count=0

    # Loop through the file to count the rows
    while read local cur_line
    do
        (( row_count++ ))
    done < $1

    # Display the result
    echo $row_count $col_count

    # Remove temp file
    rm -f "temp_file$$"

    exit 0
}


# NAME
#   transpose - reflect the matrix elements MxN => NxM
# SYNOPSIS
#   transpose [matrix]
# DESCRIPTION
#   Returns a new matrix to stdout with the elements reflected over the
#   diagonal when it is given a valid matrix from stdin or a file
# This post was used in figuring out the looping action (s/e/d isn't allowed!)
# https://stackoverflow.com/questions/1729824/an-efficient-way-to
# -transpose-a-file-in-bash

transpose()
{
    temp="trns_temp$$"

    # Define trap statement to erase TMP file on an interrupt signal
    trap "rm -f "trns_temp$$"; echo 'CTRL+C received, exiting'; exit 11" INT HUP TERM

    # Count the number of words in line 1
    local col_count=$( head -n 1 $1 | wc -w )
    
    # Loop through each row and capture tab delimited fields and append them
    # to the temp file 
    for (( i=1; i <= col_count; i++ ))
    do
        cut -f "$i" "$1" | paste -s >> "$temp"
    done

    # Display the result
    cat "$temp"

    # Remove any temp files
    rm -f "$temp"
    rm -f "temp_file$$"

    exit 0
}


# NAME
#   mean - returns the mean of each column of a valid matrix
# SYNOPSIS
#   mean [matrix]
# DESCRIPTION
#   Returns the mean of each column of a matrix to stdout when it is given
#   a valid matrix from stdin or a file

mean()
{
    temp="mean_temp$$"

    # Define trap statement to erase TMP file on an interrupt signal
    trap "rm -f "mean_temp$$"; echo 'CTRL+C received, exiting'; exit 11" INT HUP TERM

    # Retrieve the matrix dimensions
    local dims_m=$( dims $1 )
    local row_count=$( echo "$dims_m" | cut -d ' ' -f 1 )
    local col_count=$( echo "$dims_m" | cut -d ' ' -f 2 )


    #local col_count=$( head -n 1 $1 | wc -w )    

    for (( i=0; i <= col_count; i++ ))
    do

        sum=0
        avg=0

        


        #cut -f "$i" "$1" > "$temp"
        #echo $col
        #echo $col_nums


        while read -a line
        do
            sum="$(( sum + "${line[i]}" ))"
            echo -e "${line[i]}"
        done < $1

        #echo $sum

        # while read num
        # do
            
        #     #sum=$(( $sum + $num ))
        #     echo $i
        #     echo -e "sum: $sum"
        #     echo -e "num:  $num"
        # done < "$temp"

        

        #local avg="$(( $sum / $row_count ))"
        #local avg="$((( $sum + ( $row_count / 2 ) * ( $sum > 0 ) * 2 - 1 )) / $row_count ))"
        #echo $avg

        # if [[ "$i" -lt "$col_count" ]]
        # then
        #     printf "%d\t" "$avg"
        # else
        #     printf "%d\n" "$avg"
        # fi
    done

    # Remove any temp files
    rm -f "$temp"
    rm -f "temp_file$$"

    exit 0
}


# NAME
#   add - sums 2 equal dimension matrices element-wise
# SYNOPSIS
#   add [Matrix_left  Matrix_right]
# DESCRIPTION
#   Returns to stdout the matrix representing the element-wise sums of 2 equal
#   dimension matrices

add()
{
    temp="add_temp$$"

    # Define trap statement to erase TMP file on an interrupt signal
    trap "rm -f "add_temp$$"; echo 'CTRL+C received, exiting'; exit 11" INT HUP TERM

    # Test that the matrices have identical dimensions
    local dim_m_lft=$(dims $1)
    local dim_m_rgt=$(dims $2)

    if [ "$dim_m_lft" = "$dim_m_rgt" ]
    then
        echo "Hello"


    else
        echo "Add function requires equal dimension matrices" 1>&2
        exit 12
    fi
    
    # Remove temp file
    rm -f "$temp"

    exit 0
}


# NAME
#   multiply - sums 2 equal dimension matrices element-wise
# SYNOPSIS
#   multiply [Matrix_left  Matrix_right]
# DESCRIPTION
#   Returns to stdout the product of an MxN and NxP matrix and to produce an
#   MxP matrix

multiply()
{
    temp="mult_temp$$"

    # Define trap statement to erase TMP file on an interrupt signal
    trap "rm -f "mult_temp$$"; echo 'CTRL+C received, exiting'; exit 11" INT HUP TERM

    # Test that the matrices have identical dimensions
    local dims_m_lft=$(dims $1)
    local dims_m_rgt=$(dims $2)

    local m_lft_rows=$( echo "$dims_m_lft" | cut -d ' ' -f 1 )
    local m_lft_cols=$( echo "$dims_m_lft" | cut -d ' ' -f 2 )

    local m_rgt_rows=$( echo "$dims_m_rgt" | cut -d ' ' -f 1 )
    local m_lft_cols=$( echo "$dims_m_rgt" | cut -d ' ' -f 2 )

    # Test that the matrices have identical dimensions
    if [ "$m_lft_cols" = "$m_rgt_rows" ]
    then
        echo "Hello"


    else
        echo "Multiply function requires MxN * NxP = MxP dimensions" 1>&2
        exit 13
    fi
    
    # Remove temp file
    rm -f "$temp"

    exit 0
}


##  Script execution
###############################################################################

# Validate that the number of arguments is between 1 and 3
[ $# -lt 1 ] && echo "Invalid command: No Function called" 1>&2
[ $? -eq 0 ] && exit 2

[ $# -gt 3 ] && echo "Invalid command: Too many arguments provided" 1>&2
[ $? -eq 0 ] && exit 3


# Check the argument count of the single arg functions 
if [ "$1" = "dims" ] || [ "$1" = "mean" ] || [ "$1" = "transpose" ]
then
    # Use TMP to hold the value of stdin for 1 arg call
    if [ "$#" = "1" ]
    then
        # Take in the stdin input into TMP
        cat > "$TMP"

        # Validate the input temp file from stdin and delete if malformed
        [ ! -f "$TMP" ] || [ ! -r "$TMP" ] && echo "Matrix file is invalid" 1>&2
        [ $? -eq 0 ] && rm -f "temp_file$$" && exit 4

    elif [ "$#" = "2" ]
    then
        # For a 2 arg call, a file was provided, so assign it to TMP
        TMP=$2

        # Validate the provided file
        [ ! -f "$TMP" ] || [ ! -r "$TMP" ] && echo "Matrix file is invalid" 1>&2
        [ $? -eq 0 ] && exit 5

    elif [ "$#" = "3" ]
    then
        echo -e "Invalid command: $1 only accepts 1 argument" 1>&2
        exit 6
    fi
fi


# Check the argument count of 2 arg functions
if [ "$1" = "add" ] || [ "$1" = "multiply" ]
then   
    # Verify the arg count
    [ $# -ne 3 ] && echo "Invalid command: 2 matrix files are required" 1>&2
    [ $? -eq 0 ] && exit 7

    # Validate matrix 1
    [ ! -f $2 ] || [ ! -r $2 ] && echo "Matrix file 1 is invalid" 1>&2
    [ $? -eq 0 ] && exit 8

    # Validate matrix 2
    [ ! -f $3 ] || [ ! -r $3 ] && echo "Matrix file 2 is invalid" 1>&2
    [ $? -eq 0 ] && exit 9
fi


# Call the requested bash function in arg 1 with relevant arguments
case $1 in
    dims)
        $1 $TMP
    ;;
    transpose)
        $1 $TMP
    ;;
    mean)
        $1 $TMP
    ;;
    add)
        $1 "${@:2}"
    ;;
    multiply)
        $1 "${@:2}"
    ;;
    *)
        echo "No valid function called, exiting" 1>&2
        rm -f "temp_file$$"
        exit 10
    ;;
esac
